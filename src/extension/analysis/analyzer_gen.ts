// This file was generated by Dart-Code-Class-Builder
// and should not be hand-edited!

import * as vs from "vscode";
import * as as from "../../shared/analysis_server_types";
import { Logger } from "../../shared/interfaces";
import { UnknownNotification, UnknownResponse } from "../../shared/services/interfaces";
import { StdIOService } from "../../shared/services/stdio_service";

export abstract class AnalyzerGen extends StdIOService<UnknownNotification> {
	constructor(logger: Logger, maxLogLineLength: number | undefined) {
		super(logger, maxLogLineLength);
	}

	protected buildRequest<TReq>(id: number, method: string, params?: TReq): { id: string, method: string, params?: TReq } {
		return Object.assign(
			super.buildRequest(id, method, params),
			{ clientRequestTime: Date.now() },
		);
	}

	private serverConnectedSubscriptions: ((notification: as.ServerConnectedNotification) => void)[] = [];
	private serverErrorSubscriptions: ((notification: as.ServerErrorNotification) => void)[] = [];
	private serverStatusSubscriptions: ((notification: as.ServerStatusNotification) => void)[] = [];
	private analysisAnalyzedFilesSubscriptions: ((notification: as.AnalysisAnalyzedFilesNotification) => void)[] = [];
	private analysisClosingLabelsSubscriptions: ((notification: as.AnalysisClosingLabelsNotification) => void)[] = [];
	private analysisErrorsSubscriptions: ((notification: as.AnalysisErrorsNotification) => void)[] = [];
	private analysisFlushResultsSubscriptions: ((notification: as.AnalysisFlushResultsNotification) => void)[] = [];
	private analysisFoldingSubscriptions: ((notification: as.AnalysisFoldingNotification) => void)[] = [];
	private analysisHighlightsSubscriptions: ((notification: as.AnalysisHighlightsNotification) => void)[] = [];
	private analysisImplementedSubscriptions: ((notification: as.AnalysisImplementedNotification) => void)[] = [];
	private analysisInvalidateSubscriptions: ((notification: as.AnalysisInvalidateNotification) => void)[] = [];
	private analysisNavigationSubscriptions: ((notification: as.AnalysisNavigationNotification) => void)[] = [];
	private analysisOccurrencesSubscriptions: ((notification: as.AnalysisOccurrencesNotification) => void)[] = [];
	private analysisOutlineSubscriptions: ((notification: as.AnalysisOutlineNotification) => void)[] = [];
	private analysisOverridesSubscriptions: ((notification: as.AnalysisOverridesNotification) => void)[] = [];
	private completionResultsSubscriptions: ((notification: as.CompletionResultsNotification) => void)[] = [];
	private completionAvailableSuggestionsSubscriptions: ((notification: as.CompletionAvailableSuggestionsNotification) => void)[] = [];
	private completionExistingImportsSubscriptions: ((notification: as.CompletionExistingImportsNotification) => void)[] = [];
	private searchResultsSubscriptions: ((notification: as.SearchResultsNotification) => void)[] = [];
	private executionLaunchDataSubscriptions: ((notification: as.ExecutionLaunchDataNotification) => void)[] = [];
	private flutterOutlineSubscriptions: ((notification: as.FlutterOutlineNotification) => void)[] = [];

	protected async handleNotification(evt: UnknownNotification): Promise<void> {
		switch (evt.event) {
			case "server.connected":
				await this.notify(this.serverConnectedSubscriptions, <as.ServerConnectedNotification>evt.params);
				break;
			case "server.error":
				await this.notify(this.serverErrorSubscriptions, <as.ServerErrorNotification>evt.params);
				break;
			case "server.status":
				await this.notify(this.serverStatusSubscriptions, <as.ServerStatusNotification>evt.params);
				break;
			case "analysis.analyzedFiles":
				await this.notify(this.analysisAnalyzedFilesSubscriptions, <as.AnalysisAnalyzedFilesNotification>evt.params);
				break;
			case "analysis.closingLabels":
				await this.notify(this.analysisClosingLabelsSubscriptions, <as.AnalysisClosingLabelsNotification>evt.params);
				break;
			case "analysis.errors":
				await this.notify(this.analysisErrorsSubscriptions, <as.AnalysisErrorsNotification>evt.params);
				break;
			case "analysis.flushResults":
				await this.notify(this.analysisFlushResultsSubscriptions, <as.AnalysisFlushResultsNotification>evt.params);
				break;
			case "analysis.folding":
				await this.notify(this.analysisFoldingSubscriptions, <as.AnalysisFoldingNotification>evt.params);
				break;
			case "analysis.highlights":
				await this.notify(this.analysisHighlightsSubscriptions, <as.AnalysisHighlightsNotification>evt.params);
				break;
			case "analysis.implemented":
				await this.notify(this.analysisImplementedSubscriptions, <as.AnalysisImplementedNotification>evt.params);
				break;
			case "analysis.invalidate":
				await this.notify(this.analysisInvalidateSubscriptions, <as.AnalysisInvalidateNotification>evt.params);
				break;
			case "analysis.navigation":
				await this.notify(this.analysisNavigationSubscriptions, <as.AnalysisNavigationNotification>evt.params);
				break;
			case "analysis.occurrences":
				await this.notify(this.analysisOccurrencesSubscriptions, <as.AnalysisOccurrencesNotification>evt.params);
				break;
			case "analysis.outline":
				await this.notify(this.analysisOutlineSubscriptions, <as.AnalysisOutlineNotification>evt.params);
				break;
			case "analysis.overrides":
				await this.notify(this.analysisOverridesSubscriptions, <as.AnalysisOverridesNotification>evt.params);
				break;
			case "completion.results":
				await this.notify(this.completionResultsSubscriptions, <as.CompletionResultsNotification>evt.params);
				break;
			case "completion.availableSuggestions":
				await this.notify(this.completionAvailableSuggestionsSubscriptions, <as.CompletionAvailableSuggestionsNotification>evt.params);
				break;
			case "completion.existingImports":
				await this.notify(this.completionExistingImportsSubscriptions, <as.CompletionExistingImportsNotification>evt.params);
				break;
			case "search.results":
				await this.notify(this.searchResultsSubscriptions, <as.SearchResultsNotification>evt.params);
				break;
			case "execution.launchData":
				await this.notify(this.executionLaunchDataSubscriptions, <as.ExecutionLaunchDataNotification>evt.params);
				break;
			case "flutter.outline":
				await this.notify(this.flutterOutlineSubscriptions, <as.FlutterOutlineNotification>evt.params);
				break;
		}
	}

	/**
	Reports that the server is running. This notification is
	issued once after the server has started running but before
	any requests are processed to let the client know that it
	started correctly.
	It is not possible to subscribe to or unsubscribe from this
	notification.
	*/
	registerForServerConnected(subscriber: (notification: as.ServerConnectedNotification) => void): vs.Disposable {
		return this.subscribe(this.serverConnectedSubscriptions, subscriber);
	}

	/**
	Reports that an unexpected error has occurred while
	executing the server. This notification is not used for
	problems with specific requests (which are returned as part
	of the response) but is used for exceptions that occur while
	performing other tasks, such as analysis or preparing
	notifications.
	It is not possible to subscribe to or unsubscribe from this
	notification.
	*/
	registerForServerError(subscriber: (notification: as.ServerErrorNotification) => void): vs.Disposable {
		return this.subscribe(this.serverErrorSubscriptions, subscriber);
	}

	/**
	Reports the current status of the server. Parameters are
	omitted if there has been no change in the status
	represented by that parameter.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "STATUS" in
	the list of services passed in a server.setSubscriptions
	request.
	*/
	registerForServerStatus(subscriber: (notification: as.ServerStatusNotification) => void): vs.Disposable {
		return this.subscribe(this.serverStatusSubscriptions, subscriber);
	}

	/**
	Reports the paths of the files that are being analyzed.
	This notification is not subscribed to by default. Clients can
	subscribe by including the value "ANALYZED_FILES" in the list
	of services passed in an analysis.setGeneralSubscriptions request.
	*/
	registerForAnalysisAnalyzedFiles(subscriber: (notification: as.AnalysisAnalyzedFilesNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisAnalyzedFilesSubscriptions, subscriber);
	}

	/**
	Reports closing labels relevant to a given file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "CLOSING_LABELS"
	in the list of services passed in an
	analysis.setSubscriptions request.
	*/
	registerForAnalysisClosingLabels(subscriber: (notification: as.AnalysisClosingLabelsNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisClosingLabelsSubscriptions, subscriber);
	}

	/**
	Reports the errors associated with a given file. The set of
	errors included in the notification is always a complete
	list that supersedes any previously reported errors.
	*/
	registerForAnalysisErrors(subscriber: (notification: as.AnalysisErrorsNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisErrorsSubscriptions, subscriber);
	}

	/**
	Reports that any analysis results that were previously
	associated with the given files should be considered to be
	invalid because those files are no longer being analyzed,
	either because the analysis root that contained it is no
	longer being analyzed or because the file no longer exists.
	If a file is included in this notification and at some later
	time a notification with results for the file is received,
	clients should assume that the file is once again being
	analyzed and the information should be processed.
	It is not possible to subscribe to or unsubscribe from this
	notification.
	*/
	registerForAnalysisFlushResults(subscriber: (notification: as.AnalysisFlushResultsNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisFlushResultsSubscriptions, subscriber);
	}

	/**
	Reports the folding regions associated with a given
	file. Folding regions can be nested, but will not be
	overlapping. Nesting occurs when a foldable element, such as
	a method, is nested inside another foldable element such as
	a class.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "FOLDING" in
	the list of services passed in an analysis.setSubscriptions
	request.
	*/
	registerForAnalysisFolding(subscriber: (notification: as.AnalysisFoldingNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisFoldingSubscriptions, subscriber);
	}

	/**
	Reports the highlight regions associated with a given file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "HIGHLIGHTS"
	in the list of services passed in an
	analysis.setSubscriptions request.
	*/
	registerForAnalysisHighlights(subscriber: (notification: as.AnalysisHighlightsNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisHighlightsSubscriptions, subscriber);
	}

	/**
	Reports the classes that are implemented or extended and
	class members that are implemented or overridden in a file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "IMPLEMENTED" in
	the list of services passed in an analysis.setSubscriptions
	request.
	*/
	registerForAnalysisImplemented(subscriber: (notification: as.AnalysisImplementedNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisImplementedSubscriptions, subscriber);
	}

	/**
	Reports that the navigation information associated with a region of a
	single file has become invalid and should be re-requested.
	This notification is not subscribed to by default. Clients can
	subscribe by including the value "INVALIDATE" in the list of
	services passed in an analysis.setSubscriptions request.
	*/
	registerForAnalysisInvalidate(subscriber: (notification: as.AnalysisInvalidateNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisInvalidateSubscriptions, subscriber);
	}

	/**
	Reports the navigation targets associated with a given file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "NAVIGATION"
	in the list of services passed in an
	analysis.setSubscriptions request.
	*/
	registerForAnalysisNavigation(subscriber: (notification: as.AnalysisNavigationNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisNavigationSubscriptions, subscriber);
	}

	/**
	Reports the occurrences of references to elements within a
	single file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "OCCURRENCES"
	in the list of services passed in an
	analysis.setSubscriptions request.
	*/
	registerForAnalysisOccurrences(subscriber: (notification: as.AnalysisOccurrencesNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisOccurrencesSubscriptions, subscriber);
	}

	/**
	Reports the outline associated with a single file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "OUTLINE" in
	the list of services passed in an analysis.setSubscriptions
	request.
	*/
	registerForAnalysisOutline(subscriber: (notification: as.AnalysisOutlineNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisOutlineSubscriptions, subscriber);
	}

	/**
	Reports the overriding members in a file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "OVERRIDES" in
	the list of services passed in an analysis.setSubscriptions
	request.
	*/
	registerForAnalysisOverrides(subscriber: (notification: as.AnalysisOverridesNotification) => void): vs.Disposable {
		return this.subscribe(this.analysisOverridesSubscriptions, subscriber);
	}

	/**
	Reports the completion suggestions that should be presented
	to the user. The set of suggestions included in the
	notification is always a complete list that supersedes any
	previously reported suggestions.
	*/
	registerForCompletionResults(subscriber: (notification: as.CompletionResultsNotification) => void): vs.Disposable {
		return this.subscribe(this.completionResultsSubscriptions, subscriber);
	}

	/**
	Reports the pre-computed, candidate completions from symbols defined
	in a corresponding library. This notification may be sent multiple times.
	When a notification is processed, clients should replace any previous
	information about the libraries in the list of changedLibraries, discard
	any information about the libraries in the list of removedLibraries, and
	preserve any previously received information about any libraries that are
	not included in either list.
	*/
	registerForCompletionAvailableSuggestions(subscriber: (notification: as.CompletionAvailableSuggestionsNotification) => void): vs.Disposable {
		return this.subscribe(this.completionAvailableSuggestionsSubscriptions, subscriber);
	}

	/**
	Reports existing imports in a library. This notification may be sent
	multiple times for a library. When a notification is processed, clients
	should replace any previous information for the library.
	*/
	registerForCompletionExistingImports(subscriber: (notification: as.CompletionExistingImportsNotification) => void): vs.Disposable {
		return this.subscribe(this.completionExistingImportsSubscriptions, subscriber);
	}

	/**
	Reports some or all of the results of performing a requested
	search. Unlike other notifications, this notification
	contains search results that should be added to any
	previously received search results associated with the same
	search id.
	*/
	registerForSearchResults(subscriber: (notification: as.SearchResultsNotification) => void): vs.Disposable {
		return this.subscribe(this.searchResultsSubscriptions, subscriber);
	}

	/**
	Reports information needed to allow a single file to be launched.
	This notification is not subscribed to by default. Clients can
	subscribe by including the value "LAUNCH_DATA" in the list of services
	passed in an execution.setSubscriptions request.
	*/
	registerForExecutionLaunchData(subscriber: (notification: as.ExecutionLaunchDataNotification) => void): vs.Disposable {
		return this.subscribe(this.executionLaunchDataSubscriptions, subscriber);
	}

	/**
	Reports the Flutter outline associated with a single file.
	This notification is not subscribed to by default. Clients
	can subscribe by including the value "OUTLINE" in
	the list of services passed in an flutter.setSubscriptions
	request.
	*/
	registerForFlutterOutline(subscriber: (notification: as.FlutterOutlineNotification) => void): vs.Disposable {
		return this.subscribe(this.flutterOutlineSubscriptions, subscriber);
	}

	/**
	Return the version number of the analysis server.
	*/
	serverGetVersion(): Promise<as.ServerGetVersionResponse> {
		return this.sendRequest("server.getVersion");
	}

	/**
	Cleanly shutdown the analysis server. Requests that are
	received after this request will not be processed. Requests
	that were received before this request, but for which a
	response has not yet been sent, will not be responded to. No
	further responses or notifications will be sent after the
	response to this request has been sent.
	*/
	serverShutdown(): Promise<UnknownResponse> {
		return this.sendRequest("server.shutdown");
	}

	/**
	Subscribe for services. All previous subscriptions are
	replaced by the given set of services.
	It is an error if any of the elements in the list are not
	valid services. If there is an error, then the current
	subscriptions will remain unchanged.
	*/
	serverSetSubscriptions(request: as.ServerSetSubscriptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("server.setSubscriptions", request);
	}

	/**
	Return the errors associated with the given file. If the
	errors for the given file have not yet been computed, or the
	most recently computed errors for the given file are out of
	date, then the response for this request will be delayed
	until they have been computed. If some or all of the errors
	for the file cannot be computed, then the subset of the
	errors that can be computed will be returned and the
	response will contain an error to indicate why the errors
	could not be computed. If the content of the file changes after this
	request was received but before a response could be sent, then an
	error of type CONTENT_MODIFIED will be generated.
	This request is intended to be used by clients that cannot
	asynchronously apply updated error information. Clients that
	can apply error information as it becomes available
	should use the information provided by the 'analysis.errors'
	notification.
	If a request is made for a file which does not exist, or
	which is not currently subject to analysis (e.g. because it
	is not associated with any analysis root specified to
	analysis.setAnalysisRoots), an error of type
	GET_ERRORS_INVALID_FILE will be generated.
	*/
	analysisGetErrors(request: as.AnalysisGetErrorsRequest): Promise<as.AnalysisGetErrorsResponse> {
		return this.sendRequest("analysis.getErrors", request);
	}

	/**
	Return the hover information associate with the given
	location. If some or all of the hover information is not
	available at the time this request is processed the
	information will be omitted from the response.
	*/
	analysisGetHover(request: as.AnalysisGetHoverRequest): Promise<as.AnalysisGetHoverResponse> {
		return this.sendRequest("analysis.getHover", request);
	}

	/**
	Return a description of all of the elements referenced in a given region
	of a given file that come from imported libraries.
	If a request is made for a file that does not exist, or that is not
	currently subject to analysis (e.g. because it is not associated with any
	analysis root specified via analysis.setAnalysisRoots), an error of type
	GET_IMPORTED_ELEMENTS_INVALID_FILE will be generated.
	*/
	analysisGetImportedElements(request: as.AnalysisGetImportedElementsRequest): Promise<as.AnalysisGetImportedElementsResponse> {
		return this.sendRequest("analysis.getImportedElements", request);
	}

	/**
	Return library dependency information for use in client-side indexing
	and package URI resolution.
	Clients that are only using the libraries field should consider using the
	analyzedFiles notification instead.
	*/
	analysisGetLibraryDependencies(): Promise<as.AnalysisGetLibraryDependenciesResponse> {
		return this.sendRequest("analysis.getLibraryDependencies");
	}

	/**
	Return the navigation information associated with the given region of
	the given file. If the navigation information for the given file has
	not yet been computed, or the most recently computed navigation
	information for the given file is out of date, then the response for
	this request will be delayed until it has been computed. If the
	content of the file changes after this request was received but before
	a response could be sent, then an error of type
	CONTENT_MODIFIED will be generated.
	If a navigation region overlaps (but extends either before or after)
	the given region of the file it will be included in the result. This
	means that it is theoretically possible to get the same navigation
	region in response to multiple requests. Clients can avoid this by
	always choosing a region that starts at the beginning of a line and
	ends at the end of a (possibly different) line in the file.
	If a request is made for a file which does not exist, or
	which is not currently subject to analysis (e.g. because it
	is not associated with any analysis root specified to
	analysis.setAnalysisRoots), an error of type
	GET_NAVIGATION_INVALID_FILE will be generated.
	*/
	analysisGetNavigation(request: as.AnalysisGetNavigationRequest): Promise<as.AnalysisGetNavigationResponse> {
		return this.sendRequest("analysis.getNavigation", request);
	}

	/**
	Return the transitive closure of reachable sources for a given file.
	If a request is made for a file which does not exist, or
	which is not currently subject to analysis (e.g. because it
	is not associated with any analysis root specified to
	analysis.setAnalysisRoots), an error of type
	GET_REACHABLE_SOURCES_INVALID_FILE will be generated.
	*/
	analysisGetReachableSources(request: as.AnalysisGetReachableSourcesRequest): Promise<as.AnalysisGetReachableSourcesResponse> {
		return this.sendRequest("analysis.getReachableSources", request);
	}

	/**
	Return the signature information associated with the given
	location in the given file. If the signature information
	for the given file has not yet been computed, or the most
	recently computed signature information for the given file
	is out of date, then the response for this request will be
	delayed until it has been computed.
	If a request is made for a file which does not exist, or
	which is not currently subject to analysis (e.g. because it
	is not associated with any analysis root specified to
	analysis.setAnalysisRoots), an error of type
	GET_SIGNATURE_INVALID_FILE will be generated.
	If the location given is not inside the argument list for a
	function (including method and constructor) invocation, then
	an error of type GET_SIGNATURE_INVALID_OFFSET will
	be generated. If the location is inside an argument list but
	the function is not defined or cannot be determined (such as
	a method invocation where the target has type 'dynamic')
	then an error of type GET_SIGNATURE_UNKNOWN_FUNCTION
	will be generated.
	*/
	analysisGetSignature(request: as.AnalysisGetSignatureRequest): Promise<as.AnalysisGetSignatureResponse> {
		return this.sendRequest("analysis.getSignature", request);
	}

	/**
	Force re-reading of all potentially changed files, re-resolving of all
	referenced URIs, and corresponding re-analysis of everything affected in
	the current analysis roots.
	*/
	analysisReanalyze(): Promise<UnknownResponse> {
		return this.sendRequest("analysis.reanalyze");
	}

	/**
	Sets the root paths used to determine which files to analyze. The set
	of files to be analyzed are all of the files in one of the root paths
	that are not either explicitly or implicitly excluded. A file is
	explicitly excluded if it is in one of the excluded paths. A file is
	implicitly excluded if it is in a subdirectory of one of the root
	paths where the name of the subdirectory starts with a period (that
	is, a hidden directory).
	Note that this request determines the set of requested
	analysis roots. The actual set of analysis roots at any
	given time is the intersection of this set with the set of
	files and directories actually present on the
	filesystem. When the filesystem changes, the actual set of
	analysis roots is automatically updated, but the set of
	requested analysis roots is unchanged. This means that if
	the client sets an analysis root before the root becomes
	visible to server in the filesystem, there is no error; once
	the server sees the root in the filesystem it will start
	analyzing it. Similarly, server will stop analyzing files
	that are removed from the file system but they will remain
	in the set of requested roots.
	If an included path represents a file, then server will look
	in the directory containing the file for a pubspec.yaml
	file. If none is found, then the parents of the directory
	will be searched until such a file is found or the root of
	the file system is reached. If such a file is found, it will
	be used to resolve package: URIâ€™s within the file.
	*/
	analysisSetAnalysisRoots(request: as.AnalysisSetAnalysisRootsRequest): Promise<UnknownResponse> {
		return this.sendRequest("analysis.setAnalysisRoots", request);
	}

	/**
	Subscribe for general services (that is, services that are not
	specific to individual files). All previous subscriptions are replaced
	by the given set of services.
	It is an error if any of the elements in the list are not valid
	services. If there is an error, then the current subscriptions will
	remain unchanged.
	*/
	analysisSetGeneralSubscriptions(request: as.AnalysisSetGeneralSubscriptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("analysis.setGeneralSubscriptions", request);
	}

	/**
	Set the priority files to the files in the given list. A
	priority file is a file that is given priority when
	scheduling which analysis work to do first. The list
	typically contains those files that are visible to the user
	and those for which analysis results will have the biggest
	impact on the user experience. The order of the files within
	the list is significant: the first file will be given higher
	priority than the second, the second higher priority than
	the third, and so on.
	Note that this request determines the set of requested
	priority files. The actual set of priority files is the
	intersection of the requested set of priority files with the
	set of files currently subject to analysis. (See
	analysis.setSubscriptions for a description of files that
	are subject to analysis.)
	If a requested priority file is a directory it is ignored,
	but remains in the set of requested priority files so that
	if it later becomes a file it can be included in the set of
	actual priority files.
	*/
	analysisSetPriorityFiles(request: as.AnalysisSetPriorityFilesRequest): Promise<UnknownResponse> {
		return this.sendRequest("analysis.setPriorityFiles", request);
	}

	/**
	Subscribe for services that are specific to individual files.
	All previous subscriptions are replaced by the current set of
	subscriptions. If a given service is not included as a key in the map
	then no files will be subscribed to the service, exactly as if the
	service had been included in the map with an explicit empty list of
	files.
	Note that this request determines the set of requested
	subscriptions. The actual set of subscriptions at any given
	time is the intersection of this set with the set of files
	currently subject to analysis. The files currently subject
	to analysis are the set of files contained within an actual
	analysis root but not excluded, plus all of the files
	transitively reachable from those files via import, export
	and part directives. (See analysis.setAnalysisRoots for an
	explanation of how the actual analysis roots are
	determined.) When the actual analysis roots change, the
	actual set of subscriptions is automatically updated, but
	the set of requested subscriptions is unchanged.
	If a requested subscription is a directory it is ignored,
	but remains in the set of requested subscriptions so that if
	it later becomes a file it can be included in the set of
	actual subscriptions.
	It is an error if any of the keys in the map are not valid
	services. If there is an error, then the existing
	subscriptions will remain unchanged.
	*/
	analysisSetSubscriptions(request: as.AnalysisSetSubscriptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("analysis.setSubscriptions", request);
	}

	/**
	Update the content of one or more files. Files that were
	previously updated but not included in this update remain
	unchanged. This effectively represents an overlay of the
	filesystem. The files whose content is overridden are
	therefore seen by server as being files with the given
	content, even if the files do not exist on the filesystem or
	if the file path represents the path to a directory on the
	filesystem.
	*/
	analysisUpdateContent(request: as.AnalysisUpdateContentRequest): Promise<UnknownResponse> {
		return this.sendRequest("analysis.updateContent", request);
	}

	/**
	Deprecated: all of the options can be set by users in
	an analysis options file.
	Update the options controlling analysis based on the given
	set of options. Any options that are not included in the
	analysis options will not be changed. If there are options
	in the analysis options that are not valid, they will be
	silently ignored.
	*/
	analysisUpdateOptions(request: as.AnalysisUpdateOptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("analysis.updateOptions", request);
	}

	/**
	Request that completion suggestions for the given offset in
	the given file be returned.
	*/
	completionGetSuggestions(request: as.CompletionGetSuggestionsRequest): Promise<as.CompletionGetSuggestionsResponse> {
		return this.sendRequest("completion.getSuggestions", request);
	}

	/**
	Subscribe for completion services. All previous subscriptions are
	replaced by the given set of services.
	It is an error if any of the elements in the list are not valid
	services. If there is an error, then the current subscriptions will
	remain unchanged.
	*/
	completionSetSubscriptions(request: as.CompletionSetSubscriptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("completion.setSubscriptions", request);
	}

	/**
	The client can make this request to express interest in certain
	libraries to receive completion suggestions from based on the client path.
	If this request is received before the client has used
	'completion.setSubscriptions' to subscribe to the AVAILABLE_SUGGESTION_SETS
	service, then an error of type NOT_SUBSCRIBED_TO_AVAILABLE_SUGGESTION_SETS
	will be generated. All previous paths are replaced by the given set of paths.
	*/
	completionRegisterLibraryPaths(request: as.CompletionRegisterLibraryPathsRequest): Promise<UnknownResponse> {
		return this.sendRequest("completion.registerLibraryPaths", request);
	}

	/**
	Clients must make this request when the user has selected a completion
	suggestion from an AvailableSuggestionSet. Analysis server will respond with
	the text to insert as well as any SourceChange that needs to be applied
	in case the completion requires an additional import to be added. It is an error
	if the id is no longer valid, for instance if the library has been removed after
	the completion suggestion is accepted.
	*/
	completionGetSuggestionDetails(request: as.CompletionGetSuggestionDetailsRequest): Promise<as.CompletionGetSuggestionDetailsResponse> {
		return this.sendRequest("completion.getSuggestionDetails", request);
	}

	/**
	Inspect analysis server's knowledge about all of a file's tokens including
	their lexeme, type, and what element kinds would have been appropriate for
	the token's program location.
	*/
	completionListTokenDetails(request: as.CompletionListTokenDetailsRequest): Promise<as.CompletionListTokenDetailsResponse> {
		return this.sendRequest("completion.listTokenDetails", request);
	}

	/**
	Perform a search for references to the element defined or
	referenced at the given offset in the given file.
	An identifier is returned immediately, and individual
	results will be returned via the search.results notification
	as they become available.
	*/
	searchFindElementReferences(request: as.SearchFindElementReferencesRequest): Promise<as.SearchFindElementReferencesResponse> {
		return this.sendRequest("search.findElementReferences", request);
	}

	/**
	Perform a search for declarations of members whose name is
	equal to the given name.
	An identifier is returned immediately, and individual
	results will be returned via the search.results notification
	as they become available.
	*/
	searchFindMemberDeclarations(request: as.SearchFindMemberDeclarationsRequest): Promise<as.SearchFindMemberDeclarationsResponse> {
		return this.sendRequest("search.findMemberDeclarations", request);
	}

	/**
	Perform a search for references to members whose name is
	equal to the given name. This search does not check to see
	that there is a member defined with the given name, so it is
	able to find references to undefined members as well.
	An identifier is returned immediately, and individual
	results will be returned via the search.results notification
	as they become available.
	*/
	searchFindMemberReferences(request: as.SearchFindMemberReferencesRequest): Promise<as.SearchFindMemberReferencesResponse> {
		return this.sendRequest("search.findMemberReferences", request);
	}

	/**
	Perform a search for declarations of top-level elements
	(classes, typedefs, getters, setters, functions and fields)
	whose name matches the given pattern.
	An identifier is returned immediately, and individual
	results will be returned via the search.results notification
	as they become available.
	*/
	searchFindTopLevelDeclarations(request: as.SearchFindTopLevelDeclarationsRequest): Promise<as.SearchFindTopLevelDeclarationsResponse> {
		return this.sendRequest("search.findTopLevelDeclarations", request);
	}

	/**
	Return top-level and class member declarations.
	*/
	searchGetElementDeclarations(request: as.SearchGetElementDeclarationsRequest): Promise<as.SearchGetElementDeclarationsResponse> {
		return this.sendRequest("search.getElementDeclarations", request);
	}

	/**
	Return the type hierarchy of the class declared or
	referenced at the given location.
	*/
	searchGetTypeHierarchy(request: as.SearchGetTypeHierarchyRequest): Promise<as.SearchGetTypeHierarchyResponse> {
		return this.sendRequest("search.getTypeHierarchy", request);
	}

	/**
	Format the contents of a single file. The currently selected region of
	text is passed in so that the selection can be preserved across the
	formatting operation. The updated selection will be as close to
	matching the original as possible, but whitespace at the beginning or
	end of the selected region will be ignored. If preserving selection
	information is not required, zero (0) can be specified for both the
	selection offset and selection length.
	If a request is made for a file which does not exist, or which is not
	currently subject to analysis (e.g. because it is not associated with
	any analysis root specified to analysis.setAnalysisRoots), an error of
	type FORMAT_INVALID_FILE will be generated. If the source
	contains syntax errors, an error of type FORMAT_WITH_ERRORS
	will be generated.
	*/
	editFormat(request: as.EditFormatRequest): Promise<as.EditFormatResponse> {
		return this.sendRequest("edit.format", request);
	}

	/**
	Return the set of assists that are available at the given
	location. An assist is distinguished from a refactoring
	primarily by the fact that it affects a single file and does
	not require user input in order to be performed.
	*/
	editGetAssists(request: as.EditGetAssistsRequest): Promise<as.EditGetAssistsResponse> {
		return this.sendRequest("edit.getAssists", request);
	}

	/**
	Get a list of the kinds of refactorings that are valid for
	the given selection in the given file.
	*/
	editGetAvailableRefactorings(request: as.EditGetAvailableRefactoringsRequest): Promise<as.EditGetAvailableRefactoringsResponse> {
		return this.sendRequest("edit.getAvailableRefactorings", request);
	}

	/**
	Request information about edit.dartfix
	such as the list of known fixes that can be specified
	in an edit.dartfix request.
	*/
	editGetDartfixInfo(): Promise<as.EditGetDartfixInfoResponse> {
		return this.sendRequest("edit.getDartfixInfo");
	}

	/**
	Analyze the specified sources for recommended changes
	and return a set of suggested edits for those sources.
	These edits may include changes to sources outside the set
	of specified sources if a change in a specified source requires it.
	If includedFixes is specified, then those fixes will be applied.
	If includeRequiredFixes is specified, then "required" fixes will be applied
	in addition to whatever fixes are specified in includedFixes if any.
	If neither includedFixes nor includeRequiredFixes is specified,
	then all fixes will be applied.
	If excludedFixes is specified, then those fixes will not be applied
	regardless of whether they are "required" or specified in includedFixes.
	*/
	editDartfix(request: as.EditDartfixRequest): Promise<as.EditDartfixResponse> {
		return this.sendRequest("edit.dartfix", request);
	}

	/**
	Return the set of fixes that are available for the errors at
	a given offset in a given file.
	*/
	editGetFixes(request: as.EditGetFixesRequest): Promise<as.EditGetFixesResponse> {
		return this.sendRequest("edit.getFixes", request);
	}

	/**
	Get the changes required to convert the postfix template at the given
	location into the template's expanded form.
	*/
	editGetPostfixCompletion(request: as.EditGetPostfixCompletionRequest): Promise<as.EditGetPostfixCompletionResponse> {
		return this.sendRequest("edit.getPostfixCompletion", request);
	}

	/**
	Get the changes required to perform a refactoring.
	If another refactoring request is received during the processing
	of this one, an error of type REFACTORING_REQUEST_CANCELLED
	will be generated.
	*/
	editGetRefactoring(request: as.EditGetRefactoringRequest): Promise<as.EditGetRefactoringResponse> {
		return this.sendRequest("edit.getRefactoring", request);
	}

	/**
	Get the changes required to convert the partial statement at the given
	location into a syntactically valid statement. If the current statement
	is already valid the change will insert a newline plus appropriate
	indentation at the end of the line containing the offset.
	If a change that makes the statement valid cannot be determined (perhaps
	because it has not yet been implemented) the statement will be considered
	already valid and the appropriate change returned.
	*/
	editGetStatementCompletion(request: as.EditGetStatementCompletionRequest): Promise<as.EditGetStatementCompletionResponse> {
		return this.sendRequest("edit.getStatementCompletion", request);
	}

	/**
	Determine if the request postfix completion template is applicable at
	the given location in the given file.
	*/
	editIsPostfixCompletionApplicable(request: as.EditIsPostfixCompletionApplicableRequest): Promise<as.EditIsPostfixCompletionApplicableResponse> {
		return this.sendRequest("edit.isPostfixCompletionApplicable", request);
	}

	/**
	Return a list of all postfix templates currently available.
	*/
	editListPostfixCompletionTemplates(): Promise<as.EditListPostfixCompletionTemplatesResponse> {
		return this.sendRequest("edit.listPostfixCompletionTemplates");
	}

	/**
	Return a list of edits that would need to be applied in order to ensure
	that all of the elements in the specified list of imported elements are
	accessible within the library.
	If a request is made for a file that does not exist, or that is not
	currently subject to analysis (e.g. because it is not associated with any
	analysis root specified via analysis.setAnalysisRoots), an error of type
	IMPORT_ELEMENTS_INVALID_FILE will be generated.
	*/
	editImportElements(request: as.EditImportElementsRequest): Promise<as.EditImportElementsResponse> {
		return this.sendRequest("edit.importElements", request);
	}

	/**
	Sort all of the directives, unit and class members
	of the given Dart file.
	If a request is made for a file that does not exist, does not belong
	to an analysis root or is not a Dart file,
	SORT_MEMBERS_INVALID_FILE will be generated.
	If the Dart file has scan or parse errors,
	SORT_MEMBERS_PARSE_ERRORS will be generated.
	*/
	editSortMembers(request: as.EditSortMembersRequest): Promise<as.EditSortMembersResponse> {
		return this.sendRequest("edit.sortMembers", request);
	}

	/**
	Organizes all of the directives - removes unused imports and sorts
	directives of the given Dart file according to the
	Dart Style
	Guide.
	If a request is made for a file that does not exist, does not belong
	to an analysis root or is not a Dart file,
	FILE_NOT_ANALYZED will be generated.
	If directives of the Dart file cannot be organized, for example
	because it has scan or parse errors, or by other reasons,
	ORGANIZE_DIRECTIVES_ERROR will be generated. The message
	will provide details about the reason.
	*/
	editOrganizeDirectives(request: as.EditOrganizeDirectivesRequest): Promise<as.EditOrganizeDirectivesResponse> {
		return this.sendRequest("edit.organizeDirectives", request);
	}

	/**
	Create an execution context for the executable file with the given
	path. The context that is created will persist until
	execution.deleteContext is used to delete it. Clients, therefore, are
	responsible for managing the lifetime of execution contexts.
	*/
	executionCreateContext(request: as.ExecutionCreateContextRequest): Promise<as.ExecutionCreateContextResponse> {
		return this.sendRequest("execution.createContext", request);
	}

	/**
	Delete the execution context with the given identifier. The context id
	is no longer valid after this command. The server is allowed to re-use
	ids when they are no longer valid.
	*/
	executionDeleteContext(request: as.ExecutionDeleteContextRequest): Promise<UnknownResponse> {
		return this.sendRequest("execution.deleteContext", request);
	}

	/**
	Request completion suggestions for the given runtime context.
	It might take one or two requests of this type to get completion
	suggestions. The first request should have only "code", "offset",
	and "variables", but not "expressions". If there are sub-expressions that
	can have different runtime types, and are considered to be safe to
	evaluate at runtime (e.g. getters), so using their actual runtime types
	can improve completion results, the server will not include the
	"suggestions" field in the response, and instead will return the
	"expressions" field. The client will use debug API to get current runtime
	types for these sub-expressions and send another request, this time with
	"expressions". If there are no interesting sub-expressions to get
	runtime types for, or when the "expressions" field is provided by the
	client, the server will return "suggestions" in the response.
	*/
	executionGetSuggestions(request: as.ExecutionGetSuggestionsRequest): Promise<as.ExecutionGetSuggestionsResponse> {
		return this.sendRequest("execution.getSuggestions", request);
	}

	/**
	Map a URI from the execution context to the file that it corresponds
	to, or map a file to the URI that it corresponds to in the execution
	context.
	Exactly one of the file and uri fields must be provided. If both
	fields are provided, then an error of type INVALID_PARAMETER
	will be generated. Similarly, if neither field is provided, then an
	error of type INVALID_PARAMETER will be generated.
	If the file field is provided and the value is not the path of a file
	(either the file does not exist or the path references something other
	than a file), then an error of type INVALID_PARAMETER will
	be generated.
	If the uri field is provided and the value is not a valid URI or if
	the URI references something that is not a file (either a file that
	does not exist or something other than a file), then an error of type
	INVALID_PARAMETER will be generated.
	If the contextRoot used to create the execution context does not
	exist, then an error of type INVALID_EXECUTION_CONTEXT will
	be generated.
	*/
	executionMapUri(request: as.ExecutionMapUriRequest): Promise<as.ExecutionMapUriResponse> {
		return this.sendRequest("execution.mapUri", request);
	}

	/**
	Deprecated: the analysis server no longer fires
	LAUNCH_DATA events.
	Subscribe for services. All previous subscriptions are replaced by the
	given set of services.
	It is an error if any of the elements in the list are not valid
	services. If there is an error, then the current subscriptions will
	remain unchanged.
	*/
	executionSetSubscriptions(request: as.ExecutionSetSubscriptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("execution.setSubscriptions", request);
	}

	/**
	Return server diagnostics.
	*/
	diagnosticGetDiagnostics(): Promise<as.DiagnosticGetDiagnosticsResponse> {
		return this.sendRequest("diagnostic.getDiagnostics");
	}

	/**
	Return the port of the diagnostic web server. If the server is not running
	this call will start the server. If unable to start the diagnostic web
	server,
	this call will return an error of DEBUG_PORT_COULD_NOT_BE_OPENED.
	*/
	diagnosticGetServerPort(): Promise<as.DiagnosticGetServerPortResponse> {
		return this.sendRequest("diagnostic.getServerPort");
	}

	/**
	Query whether analytics is enabled.
	This flag controls whether the analysis server sends any analytics data to
	the cloud. If disabled, the analysis server does not send any analytics
	data, and any data sent to it by clients (from sendEvent and
	sendTiming) will be ignored.
	The value of this flag can be changed by other tools outside of the
	analysis server's process. When you query the flag, you get the value of
	the flag at a given moment. Clients should not use the value returned to
	decide whether or not to send the sendEvent and
	sendTiming requests. Those requests should be used
	unconditionally and server will determine whether or not it is appropriate
	to forward the information to the cloud at the time each request is
	received.
	*/
	analyticsIsEnabled(): Promise<as.AnalyticsIsEnabledResponse> {
		return this.sendRequest("analytics.isEnabled");
	}

	/**
	Enable or disable the sending of analytics data. Note that there are other
	ways for users to change this setting, so clients cannot assume that they
	have complete control over this setting. In particular, there is no
	guarantee that the result returned by the isEnabled request will
	match the last value set via this request.
	*/
	analyticsEnable(request: as.AnalyticsEnableRequest): Promise<UnknownResponse> {
		return this.sendRequest("analytics.enable", request);
	}

	/**
	Send information about client events.
	Ask the analysis server to include the fact that an action was performed
	in the client as part of the analytics data being sent. The data will only
	be included if the sending of analytics data is enabled at the time the
	request is processed. The action that was performed is indicated by the
	value of the action field.
	The value of the action field should not include the identity of the
	client. The analytics data sent by server will include the client id
	passed in using the --client-id command-line argument. The
	request will be ignored if the client id was not provided when server was
	started.
	*/
	analyticsSendEvent(request: as.AnalyticsSendEventRequest): Promise<UnknownResponse> {
		return this.sendRequest("analytics.sendEvent", request);
	}

	/**
	Send timing information for client events (e.g. code completions).
	Ask the analysis server to include the fact that a timed event occurred as
	part of the analytics data being sent. The data will only be included if
	the sending of analytics data is enabled at the time the request is
	processed.
	The value of the event field should not include the identity of the
	client. The analytics data sent by server will include the client id
	passed in using the --client-id command-line argument. The
	request will be ignored if the client id was not provided when server was
	started.
	*/
	analyticsSendTiming(request: as.AnalyticsSendTimingRequest): Promise<UnknownResponse> {
		return this.sendRequest("analytics.sendTiming", request);
	}

	/**
	Return the list of KytheEntry objects for some file, given the
	current state of the file system populated by "analysis.updateContent".
	If a request is made for a file that does not exist, or that is not
	currently subject to analysis (e.g. because it is not associated with any
	analysis root specified to analysis.setAnalysisRoots), an error of type
	GET_KYTHE_ENTRIES_INVALID_FILE will be generated.
	*/
	kytheGetKytheEntries(request: as.KytheGetKytheEntriesRequest): Promise<as.KytheGetKytheEntriesResponse> {
		return this.sendRequest("kythe.getKytheEntries", request);
	}

	/**
	Subscribe for services that are specific to individual files.
	All previous subscriptions are replaced by the current set of
	subscriptions. If a given service is not included as a key in the map
	then no files will be subscribed to the service, exactly as if the
	service had been included in the map with an explicit empty list of
	files.
	Note that this request determines the set of requested
	subscriptions. The actual set of subscriptions at any given
	time is the intersection of this set with the set of files
	currently subject to analysis. The files currently subject
	to analysis are the set of files contained within an actual
	analysis root but not excluded, plus all of the files
	transitively reachable from those files via import, export
	and part directives. (See analysis.setAnalysisRoots for an
	explanation of how the actual analysis roots are
	determined.) When the actual analysis roots change, the
	actual set of subscriptions is automatically updated, but
	the set of requested subscriptions is unchanged.
	If a requested subscription is a directory it is ignored,
	but remains in the set of requested subscriptions so that if
	it later becomes a file it can be included in the set of
	actual subscriptions.
	It is an error if any of the keys in the map are not valid
	services. If there is an error, then the existing
	subscriptions will remain unchanged.
	*/
	flutterSetSubscriptions(request: as.FlutterSetSubscriptionsRequest): Promise<UnknownResponse> {
		return this.sendRequest("flutter.setSubscriptions", request);
	}
}
